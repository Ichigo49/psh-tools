Function Copy-SqlDatabase
{
<#
.SYNOPSIS 
Migrates Sql Server databases from one Sql Server to another.

.DESCRIPTION 
This script provides the ability to migrate databases using detach/copy/attach or backup/restore. This script works with named instances, clusters and Sql Express.

By default, databases will be migrated to the destination Sql Server's default data and log directories. You can override this by specifying -ReuseSourceFolderStructure. Filestreams and filegroups are also migrated. Safety is emphasized.

THIS CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.

.PARAMETER Source
Source SQL Server.You must have sysadmin access and server version must be SQL Server version 2000 or greater.

.PARAMETER Destination
Destination Sql Server. You must have sysadmin access and server version must be SQL Server version 2000 or greater.

.PARAMETER SourceSqlCredential
Allows you to login to servers using SQL Logins as opposed to Windows Auth/Integrated/Trusted. To use:

$scred = Get-Credential, this pass $scred object to the param. 

Windows Authentication will be used if DestinationSqlCredential is not specified. To connect as a different Windows user, run PowerShell as that user.	

.PARAMETER DestinationSqlCredential
Allows you to login to servers using SQL Logins as opposed to Windows Auth/Integrated/Trusted. To use:

$dcred = Get-Credential, this pass this $dcred to the param. 

Windows Authentication will be used if DestinationSqlCredential is not specified. To connect as a different Windows user, run PowerShell as that user.	

.PARAMETER AllDatabases
This is a parameter that was included for safety, so you don't accidentally detach/attach all databases without specifying. Migrates user databases. Does not migrate system or support databases. Requires -BackupRestore or -DetachAttach. 

.PARAMETER IncludeSupportDbs
Migration of ReportServer, ReportServerTempDb, SSIDb, and distribution databases if they exist. A logfile named $SOURCE-$DESTINATION-$date-Sqls.csv will be written to the current directory. Requires -BackupRestore or -DetachAttach.

.PARAMETER BackupRestore
Use the a Copy-Only Backup and Restore Method. This parameter requires that you specify -NetworkShare in a valid UNC format (\\server\share)
	
Backups will be immediately deleted after use unless -NoBackupCleanup is specified.

.PARAMETER DetachAttach
Uses the detach/copy/attach method to perform database migrations. No files are deleted on the source. If the destination attachment fails, the source database will be reattached. File copies are performed over administrative shares (\\server\x$\mssql) using BITS. If a database is being mirrored, the mirror will be broken prior to migration. 

.PARAMETER Reattach
Reattaches all source databases after DetachAttach migration.

.PARAMETER ReuseSourceFolderStructure
By default, databases will be migrated to the destination Sql Server's default data and log directories. You can override this by specifying -ReuseSourceFolderStructure. 
The same structure on the SOURCE will be kept exactly, so consider this if you're migrating between different versions and use part of Microsoft's default Sql structure (MSSql12.INSTANCE, etc)

* note, to reuse destination folder structure, specify -WithReplace

.PARAMETER NetworkShare
Specifies the network location for the backup files. The Sql Service service accounts must read/write permission to access this location.

.PARAMETER Exclude
Excludes specified databases when performing -AllDatabases migrations. This list is auto-populated for tab completion.

.PARAMETER Databases
Migrates ONLY specified databases. This list is auto-populated for tab completion. Multiple databases are allowed.

.PARAMETER SetSourceReadOnly
Sets all migrated databases to ReadOnly prior to detach/attach & backup/restore. If -Reattach is used, db is set to read-only after reattach.

.PARAMETER NoRecovery
Sets restore to NoRecovery. Ideal for staging. 
	
.PARAMETER WithReplace
It's exactly WITH REPLACE. This is useful if you want to stage some complex file paths.
	
.PARAMETER NoBackupCleanup
By default, backups generated by the module will be deleted immediately after they are restored. Use this to skip.

.PARAMETER Force
Drops existing databases with matching names. If using -DetachAttach, -Force will break mirrors and drop dbs from Availability Groups.

.PARAMETER WhatIf 
Shows what would happen if the command were to run. No actions are actually performed. 

.PARAMETER Confirm 
Prompts you for confirmation before executing any changing operations within the command. 

.PARAMETER DbPipeline
Takes dbobject from pipeline

.PARAMETER NumberFiles
Number of files to split the backup. Default is 3.

.PARAMETER NoCopyOnly
By default, Copy-SqlDatabase backups are backed up with COPY_ONLY, which avoids breaking the LSN backup chain. This parameter will set CopyOnly to $false.

.NOTES
Tags: Migration, DisasterRecovery, Backup, Restore
Author: Chrissy LeMaire (@cl), netnerds.net
Requires: sysadmin access on SQL Servers
Limitations: Doesn't cover what it doesn't cover (replication, certificates, etc)
			 Sql Server 2000 databases cannot be directly migrated to Sql Server 2012 and above.
			 Logins within Sql Server 2012 and above logins cannot be migrated to Sql Server 2008 R2 and below.				

dbatools PowerShell module (https://dbatools.io, clemaire@gmail.com)
Copyright (C) 2016 Chrissy LeMaire

This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.


.LINK
https://dbatools.io/Copy-SqlDatabase

.EXAMPLE
Copy-SqlDatabase -Source sqlserver2014a -Destination sqlserver2014b -Database TestDB -BackupRestore -NetworkShare \\fileshare\sql\migration

Migrates a single user database TestDB using Backup and restore from instance sqlserver2014a to sqlserver2014b. Backup files are stored in \\fileshare\sql\migration.

.EXAMPLE   
Copy-SqlDatabase -Source sqlserver2014a -Destination sqlcluster -DetachAttach -Reattach

Databases will be migrated from sqlserver2014a to sqlcluster using the detach/copy files/attach method.The following will be perfomed: kick all users out of the database, detach all data/log files, move files across the network over an admin share (\\SqlSERVER\M$\MSSql...), attach file on destination server, reattach at source. If the database files (*.mdf, *.ndf, *.ldf) on *destination* exist and aren't in use, they will be overwritten.


.EXAMPLE   
Copy-SqlDatabase -Source sqlserver2014a -Destination sqlcluster -Exclude Northwind, pubs -IncludeSupportDbs -Force -BackupRestore -NetworkShare \\fileshare\sql\migration

Migrates all user databases except for Northwind and pubs by using backup/restore (copy-only). Backup files are stored in \\fileshare\sql\migration. If the database exists on the destination, it will be dropped prior to attach.

It also includes the support databases (ReportServer, ReportServerTempDb, distribution). 

#>	
	[CmdletBinding(DefaultParameterSetName = "DbMigration", SupportsShouldProcess = $true)]
	Param (
		[parameter(Position = 1, Mandatory = $false)]
		[object]$Source,
		[parameter(Position = 2, Mandatory = $true)]
		[object]$Destination,
		# Skips to 4 because dynamic param Databases is su pposed to go here but it doesn't work.

		[Alias("All")]
		[parameter(Position = 4, ParameterSetName = "DbBackup")]
		[parameter(Position = 4, ParameterSetName = "DbAttachDetach")]
		[switch]$AllDatabases,
		[parameter(Position = 5, Mandatory = $true, ParameterSetName = "DbAttachDetach")]
		[switch]$DetachAttach,
		[parameter(Position = 6, ParameterSetName = "DbAttachDetach")]
		[switch]$Reattach,
		[parameter(Position = 7, Mandatory = $true, ParameterSetName = "DbBackup")]
		[switch]$BackupRestore,
		[parameter(Position = 8, Mandatory = $true, ParameterSetName = "DbBackup",
				   HelpMessage = "Specify a valid network share in the format \\server\share that can be accessed by your account and both Sql Server service accounts.")]
		[string]$NetworkShare,
		[parameter(Position = 9, ParameterSetName = "DbBackup")]
		[switch]$WithReplace,
		[parameter(Position = 10, ParameterSetName = "DbBackup")]
		[switch]$NoRecovery,
		[parameter(Position = 11, ParameterSetName = "DbBackup")]
		[parameter(Position = 12, ParameterSetName = "DbAttachDetach")]
		[switch]$SetSourceReadOnly,
		[Alias("ReuseFolderstructure")]
		[parameter(Position = 13, ParameterSetName = "DbBackup")]
		[parameter(Position = 14, ParameterSetName = "DbAttachDetach")]
		[switch]$ReuseSourceFolderStructure,
		[parameter(Position = 15, ParameterSetName = "DbBackup")]
		[parameter(Position = 16, ParameterSetName = "DbAttachDetach")]
		[switch]$IncludeSupportDbs,
		[parameter(Position = 17, ParameterSetName = "DbBackup")]
		[switch]$NoBackupCleanup,
		[parameter(Position = 18)]
		[System.Management.Automation.PSCredential]$SourceSqlCredential,
		[parameter(Position = 19)]
		[System.Management.Automation.PSCredential]$DestinationSqlCredential,
		[parameter(Position = 20)]
		[switch]$Force,
		[parameter(ValueFromPipeline = $True)]
		[object]$DbPipeline,
		[parameter(Position = 21, ParameterSetName = "DbBackup")]
		[ValidateRange(1, 64)]
		[int]$NumberFiles = 3,
        [switch]$NoCopyOnly
	)
	
	DynamicParam { if ($source) { return Get-ParamSqlDatabases -SqlServer $source -SqlCredential $SourceSqlCredential -NoSystem } }
	
	BEGIN
	{
		# Global Database Function
		Function Get-SqlFileStructure
		{
			$dbcollection = @{ };
			$databaseProgressbar = 0
			
			foreach ($db in $databaselist)
			{
				Write-Progress -Id 1 -Activity "Processing database file structure" -PercentComplete ($databaseProgressbar / $dbcount * 100) -Status "Processing $databaseProgressbar of $dbcount"
				$dbname = $db.name
				Write-Verbose $dbname
				
				$databaseProgressbar++
				$dbstatus = $db.status.toString()
				if ($dbstatus.StartsWith("Normal") -eq $false) { continue }
				$destinationfiles = @{ }; $sourcefiles = @{ }
				
				$where = "Filetype <> 'LOG' and Filetype <> 'FULLTEXT'"
				
				$datarows = $dbfiletable.Tables.Select("dbname = '$dbname' and $where")
				
				# Data Files
				foreach ($file in $datarows)
				{
					# Destination File Structure
					$d = @{ }
					if ($ReuseSourceFolderStructure)
					{
						$d.physical = $file.filename
					}
					elseif ($WithReplace)
					{
						$name = $file.name
						$destfile = $remotedbfiletable.Tables[0].Select("dbname = '$dbname' and name = '$name'")
						$d.physical = $destfile.filename
						
						if ($null -eq $d.physical)
						{
							$directory = Get-SqlDefaultPaths $destserver data
							$filename = Split-Path $file.filename -Leaf
							$d.physical = "$directory\$filename"
						}
					}
					else
					{
						$directory = Get-SqlDefaultPaths $destserver data
						$filename = Split-Path $file.filename -Leaf
						$d.physical = "$directory\$filename"
					}
					$d.logical = $file.name
					
					$d.remotefilename = Join-AdminUNC $destnetbios $d.physical
					$destinationfiles.add($file.name, $d)
					
					# Source File Structure
					$s = @{ }
					$s.logical = $file.name
					$s.physical = $file.filename
					$s.remotefilename = Join-AdminUNC $sourcenetbios $s.physical
					$sourcefiles.add($file.name, $s)
				}
				
				# Add support for Full Text Catalogs in Sql Server 2005 and below
				if ($sourceserver.VersionMajor -lt 10)
				{
					try
					{
						$fttable = $null = $sourceserver.Databases[$dbname].ExecuteWithResults('sp_help_fulltext_catalogs')
						$allrows = $fttable.Tables[0].rows
					}
					catch
					{
						# Nothing, it's just not enabled	
					}
					
					foreach ($ftc in $allrows)
					{
						# Destination File Structure
						$d = @{ }
						$pre = "sysft_"
						$name = $ftc.name
						$physical = $ftc.Path # RootPath
						$logical = "$pre$name"
						if ($ReuseSourceFolderStructure)
						{
							$d.physical = $physical
						}
						else
						{
							$directory = Get-SqlDefaultPaths $destserver data
							if ($destserver.VersionMajor -lt 10) { $directory = "$directory\FTDATA" }
							$filename = Split-Path($physical) -leaf
							$d.physical = "$directory\$filename"
						}
						$d.logical = $logical
						$d.remotefilename = Join-AdminUNC $destnetbios $d.physical
						$destinationfiles.add($logical, $d)
						
						# Source File Structure
						$s = @{ }
						$pre = "sysft_"
						$name = $ftc.name
						$physical = $ftc.Path # RootPath
						$logical = "$pre$name"
						
						$s.logical = $logical
						$s.physical = $physical
						$s.remotefilename = Join-AdminUNC $sourcenetbios $s.physical
						$sourcefiles.add($logical, $s)
					}
				}
				
				$where = "Filetype = 'LOG'"
				
				$datarows = $dbfiletable.Tables[0].Select("dbname = '$dbname' and $where")
				
				# Log Files
				foreach ($file in $datarows)
				{
					$d = @{ }
					if ($ReuseSourceFolderStructure)
					{
						$d.physical = $file.filename
					}
					elseif ($WithReplace)
					{
						$name = $file.name
						$destfile = $remotedbfiletable.Tables[0].Select("dbname = '$dbname' and name = '$name'")
						$d.physical = $destfile.filename
						
						if ($null -eq $d.physical)
						{
							$directory = Get-SqlDefaultPaths $destserver data
							$filename = Split-Path $file.filename -Leaf
							$d.physical = "$directory\$filename"
						}
					}
					else
					{
						$directory = Get-SqlDefaultPaths $destserver log
						$filename = Split-Path $file.filename -Leaf
						$d.physical = "$directory\$filename"
					}
					$d.logical = $file.name
					$d.remotefilename = Join-AdminUNC $destnetbios $d.physical
					$destinationfiles.add($file.name, $d)
					
					$s = @{ }
					$s.logical = $file.name
					$s.physical = $file.filename
					$s.remotefilename = Join-AdminUNC $sourcenetbios $s.physical
					$sourcefiles.add($file.name, $s)
				}
				
				$location = @{ }
				$location.add("Destination", $destinationfiles)
				$location.add("Source", $sourcefiles)
				$dbcollection.Add($($db.name), $location)
			}
			
			$filestructure = [pscustomobject]@{ "databases" = $dbcollection }
			Write-Progress -id 1 -Activity "Processing database file structure" -Status "Completed" -Completed
			return $filestructure
		}
		# Backup Restore
		Function Backup-SqlDatabase
		{
			[CmdletBinding()]
			param (
				[object]$server,
				[string]$dbname,
				[string]$backupfile,
				[int]$numberfiles
			)
			
			$server.ConnectionContext.StatementTimeout = 0
			$backup = New-Object "Microsoft.SqlServer.Management.Smo.Backup"
			$backup.Database = $dbname
			$backup.Action = "Database"
			$backup.CopyOnly = $CopyOnly
			$val = 0
			
			while ($val -lt $numberfiles)
			{
				$device = New-Object "Microsoft.SqlServer.Management.Smo.BackupDeviceItem"
				$device.DeviceType = "File"
				$device.Name = $backupfile.Replace(".bak", "-$val.bak")
				$backup.Devices.Add($device)
				$val++
			}
			
			$percent = [Microsoft.SqlServer.Management.Smo.PercentCompleteEventHandler] {
				Write-Progress -id 1 -activity "Backing up database $dbname to $backupfile" -percentcomplete $_.Percent -status ([System.String]::Format("Progress: {0} %", $_.Percent))
			}
			$backup.add_PercentComplete($percent)
			$backup.PercentCompleteNotification = 1
			$backup.add_Complete($complete)
			
			Write-Progress -id 1 -activity "Backing up database $dbname to $backupfile" -percentcomplete 0 -status ([System.String]::Format("Progress: {0} %", 0))
			Write-Output "Backing up $dbname"
			
			try
			{
				$backup.SqlBackup($server)
				Write-Progress -id 1 -activity "Backing up database $dbname to $backupfile" -status "Complete" -Completed
				Write-Output "Backup succeeded"
				return $true
			}
			catch
			{
				Write-Progress -id 1 -activity "Backup" -status "Failed" -completed
				Write-Exception $_
				return $false
			}
		}
		
		Function Restore-SqlDatabase
		{
			[CmdletBinding()]
			param (
				[object]$server,
				[string]$dbname,
				[string]$backupfile,
				[object]$filestructure,
				[int]$numberfiles
			)
			
			$servername = $server.name
			$server.ConnectionContext.StatementTimeout = 0
			$restore = New-Object Microsoft.SqlServer.Management.Smo.Restore
			
			if ($WithReplace -or $server.databases[$dbname] -eq $null)
			{
				foreach ($file in $filestructure.databases[$dbname].destination.values)
				{
					$movefile = New-Object "Microsoft.SqlServer.Management.Smo.RelocateFile"
					$movefile.LogicalFileName = $file.logical
					$movefile.PhysicalFileName = $file.physical
					$null = $restore.RelocateFiles.Add($movefile)
				}
			}
			
			Write-Output "Restoring $dbname to $servername"
			
			try
			{
				
				$percent = [Microsoft.SqlServer.Management.Smo.PercentCompleteEventHandler] {
					Write-Progress -id 1 -activity "Restoring $dbname to $servername" -percentcomplete $_.Percent -status ([System.String]::Format("Progress: {0} %", $_.Percent))
				}
				$restore.add_PercentComplete($percent)
				$restore.PercentCompleteNotification = 1
				$restore.add_Complete($complete)
				$restore.ReplaceDatabase = $true
				$restore.Database = $dbname
				$restore.Action = "Database"
				$restore.NoRecovery = $NoRecovery
				$val = 0
				$filestodelete = @()
				
				while ($val -lt $numberfiles)
				{
					$device = New-Object -TypeName Microsoft.SqlServer.Management.Smo.BackupDeviceItem
					$device.devicetype = "File"
					$device.name = $backupfile.Replace(".bak", "-$val.bak")
					$restore.Devices.Add($device)
					$filestodelete += $device.name
					$val++
				}
				
				Write-Progress -id 1 -activity "Restoring $dbname to $servername" -percentcomplete 0 -status ([System.String]::Format("Progress: {0} %", 0))
				$restore.sqlrestore($server)
				Write-Progress -id 1 -activity "Restoring $dbname to $servername" -status "Complete" -Completed
				
				If ($NoBackupCleanup -eq $false)
				{
					foreach ($backupfile in $filestodelete)
					{
						try
						{
							If (Test-Path $backupfile -ErrorAction Stop)
							{
								Write-Verbose "Deleting $backupfile"
								Remove-Item $backupfile -ErrorAction Stop
							}
						}
						catch
						{
							try
							{
								Write-Verbose "Trying alternate SQL method to delete $backupfile"
								$sql = "EXEC master.sys.xp_delete_file 0, '$backupfile'"
								Write-Debug $sql
								$null = $server.ConnectionContext.ExecuteNonQuery($sql)
							}
							catch
							{
								Write-Warning "Cannot delete backup file $backupfile"
								
								# Set NoBackupCleanup so that there's a warning at the end
								$NoBackupCleanup = $true
							}
						}
					}
				}
				return $true
			}
			catch
			{
				Write-Warning "Restore failed: $($_.Exception.InnerException.Message)"
				Write-Exception $_
				return $false
			}
		}
		
		# Detach Attach 
		Function Dismount-SqlDatabase
		{
			[CmdletBinding()]
			param (
				[object]$server,
				[string]$dbname
			)
			
			$database = $server.databases[$dbname]
			if ($database.IsMirroringEnabled)
			{
				try
				{
					Write-Warning "Breaking mirror for $dbname"
					$database.ChangeMirroringState([Microsoft.SqlServer.Management.Smo.MirroringOption]::Off)
					$database.Alter()
					$database.Refresh()
					Write-Warning "Could not break mirror for $dbname. Skipping."
					
				}
				catch
				{
					Write-Exception $_
					return $false
				}
			}
			
			if ($database.AvailabilityGroupName.Length -gt 0)
			{
				$agname = $database.AvailabilityGroupName
				Write-Output "Attempting remove from Availability Group $agname"
				try
				{
					$server.AvailabilityGroups[$database.AvailabilityGroupName].AvailabilityDatabases[$dbname].Drop()
					Write-Output "Successfully removed $dbname from  detach from $agname on $($server.name)"
				}
				catch { Write-Error "Could not remove $dbname from $agname on $($server.name)"; Write-Exception $_; return $false }
			}
			
			Write-Output "Attempting detach from $dbname from $source"
			
			####### Using Sql to detach does not modify the $database collection #######
			
			$server.KillAllProcesses($dbname)
			
			try
			{
				$sql = "ALTER DATABASE [$dbname] SET SINGLE_USER WITH ROLLBACK IMMEDIATE"
				Write-Verbose $sql
				$null = $server.ConnectionContext.ExecuteNonQuery($sql)
				Write-Output "Successfully set $dbname to single-user from $source"
			}
			catch
			{
				Write-Exception $_
			}
			
			try
			{
				$sql = "EXEC master.dbo.sp_detach_db N'$dbname'"
				Write-Verbose $sql
				$null = $server.ConnectionContext.ExecuteNonQuery($sql)
				Write-Output "Successfully detached $dbname from $source"
			}
			catch
			{
				Write-Exception $_
			}
			
		}
		
		Function Mount-SqlDatabase
		{
			[CmdletBinding()]
			param (
				[object]$server,
				[string]$dbname,
				[object]$filestructure,
				[string]$dbowner
			)
			
			if ($server.Logins.Item($dbowner) -eq $null)
			{
				try
				{
					$dbowner = ($destserver.logins | Where-Object { $_.id -eq 1 }).Name
				}
				catch
				{
					$dbowner = "sa"
				}
			}
			try
			{
				$null = $server.AttachDatabase($dbname, $filestructure, $dbowner, [Microsoft.SqlServer.Management.Smo.AttachOptions]::None)
				return $true
			}
			catch { Write-Exception $_; return $false }
		}
		
		Function Start-SqlFileTransfer
		{
			<#

			SYNOPSIS
			Internal function. Uses BITS to transfer detached files (.mdf, .ndf, .ldf, and filegroups) to 
			another server over admin UNC paths. Locations of data files are kept in the
			custom object generated by Get-SqlFileStructure

			#>			
			param (
				[object]$filestructure,
				[string]$dbname
			)
			
			$copydb = $filestructure.databases[$dbname]
			$dbsource = $copydb.source
			$dbdestination = $copydb.destination
			
			foreach ($file in $dbsource.keys)
			{
				$remotefilename = $dbdestination[$file].remotefilename
				$from = $dbsource[$file].remotefilename
				try
				{
					if (Test-Path $from -pathtype container)
					{
						$null = New-Item -ItemType Directory -Path $remotefilename -Force
						Start-BitsTransfer -Source "$from\*.*" -Destination $remotefilename
						
						$directories = (Get-ChildItem -recurse $from | Where-Object { $_.PsIsContainer }).FullName
						foreach ($directory in $directories)
						{
							$newdirectory = $directory.replace($from, $remotefilename)
							$null = New-Item -ItemType Directory -Path $newdirectory -Force
							Start-BitsTransfer -Source "$directory\*.*" -Destination $newdirectory
						}
					}
					else
					{
						Write-Host "Copying $fn for $dbname"
						Start-BitsTransfer -Source $from -Destination $remotefilename
					}
					$fn = Split-Path $($dbdestination[$file].physical) -leaf
				}
				catch
				{
					try
					{
						# Sometimes BITS trips out temporarily on cloned drives.
						Start-BitsTransfer -Source $from -Destination $remotefilename
					}
					catch
					{
						Write-Warning "Start-BitsTransfer did not succeed. Now attempting with Copy-Item - no progress bar will be shown."
						try
						{
							Copy-Item -Path $from -Destination $remotefilename -ErrorAction Stop
						}
						catch
						{
							Write-Warning "Access denied. This can happen for a number of reasons including issues with cloned disks."
							Write-Warning "Alternatively, you may need to run PowerShell as Administrator, especially when running on localhost."
							break
						}
					}
				}
			}
			return $true
		}
		
		Function Start-SqlDetachAttach
		{
			<#

			.SYNOPSIS
			Internal function. Performs checks, then executes Dismount-SqlDatabase on a database, copies its files to the new server, 
			then performs Mount-SqlDatabase. $sourceserver and $destserver are SMO server objects.
			$filestructure is a custom object generated by Get-SqlFileStructure

			#>
			[CmdletBinding()]
			param (
				[object]$sourceserver,
				[object]$destserver,
				[object]$filestructure,
				[string]$dbname
			)
			
			$destfilestructure = New-Object System.Collections.Specialized.StringCollection
			$sourcefilestructure = New-Object System.Collections.Specialized.StringCollection
			$dbowner = $sourceserver.databases[$dbname].owner
			
			if ($dbowner -eq $null)
			{
				try
				{
					$dbowner = ($destserver.logins | Where-Object { $_.id -eq 1 }).Name
				}
				catch
				{
					$dbowner = "sa"
				}
			}
			
			foreach ($file in $filestructure.databases[$dbname].destination.values) { $null = $destfilestructure.add($file.physical) }
			foreach ($file in $filestructure.databases[$dbname].source.values) { $null = $sourcefilestructure.add($file.physical) }
			
			$detachresult = Dismount-SqlDatabase $sourceserver $dbname
			
			if ($detachresult)
			{
				
				$transfer = Start-SqlFileTransfer $filestructure $dbname
				if ($transfer -eq $false) { Write-Warning "Could not copy files."; return "Could not copy files." }
				$attachresult = Mount-SqlDatabase $destserver $dbname $destfilestructure $dbowner
				
				if ($attachresult -eq $true)
				{
					# add to added dbs because ATTACH was successful
					Write-Output "Successfully attached $dbname to $destination"
					return $true
				}
				else
				{
					# add to failed because ATTACH was unsuccessful
					Write-Warning "Could not attach $dbname."
					return "Could not attach database."
				}
			}
			else
			{
				# add to failed because DETACH was unsuccessful
				Write-Warning "Could not detach $dbname."
				return "Could not detach database."
			}
		}
		
	}
	
	PROCESS
	{
		$copyonly = !$NoCopyOnly
		# Convert from RuntimeDefinedParameter object to regular array
		$databases = $psboundparameters.Databases
		$exclude = $psboundparameters.Exclude
		
		if (($AllDatabases -or $IncludeSupportDbs -or $Databases) -and !$DetachAttach -and !$BackupRestore)
		{
			throw "You must specify -DetachAttach or -BackupRestore when migrating databases."
		}
		
		if ($DbPipeline.Length -gt 0)
		{
			$Source = $DbPipeline[0].parent.name
			$Databases = $DbPipeline.name
		}
		
		if ($databases -contains "master" -or $databases -contains "msdb" -or $databases -contains "tempdb") { throw "Migrating system databases is not currently supported." }
		
		if (!$AllDatabases -and !$IncludeSupportDbs -and !$Databases)
		{
			throw "You must specify a -AllDatabases or -Database to continue."
		}
		
		Write-Output "Attempting to connect to Sql Servers.."
		$sourceserver = Connect-SqlServer -SqlServer $Source -SqlCredential $SourceSqlCredential
		$destserver = Connect-SqlServer -SqlServer $Destination -SqlCredential $DestinationSqlCredential
		
		if ($DetachAttach)
		{
			if ($sourceserver.netname -eq $env:COMPUTERNAME -or $destserver.netname -eq $env:COMPUTERNAME)
			{
				If (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator"))
				{
					Write-Warning "When running DetachAttach locally on the console, it's likely you'll need to Run As Administrator. Trying anyway."
				}
			}
		}
		
		$source = $sourceserver.DomainInstanceName
		$destination = $destserver.DomainInstanceName
		
		if ($NetworkShare.Length -gt 0)
		{
			if ($(Test-SqlPath -SqlServer $sourceserver -Path $NetworkShare) -eq $false)
			{
				Write-Warning "$Source may not be able to access $NetworkShare. Trying anyway."
			}
			
			if ($(Test-SqlPath -SqlServer $destserver -Path $NetworkShare) -eq $false)
			{
				Write-Warning "$Destination may not be able to access $NetworkShare. Trying anyway."
			}
			
			if ($networkshare.StartsWith('\\'))
			{
				$shareserver = ($networkshare -split "\\")[2]
				$hostentry = ([Net.Dns]::GetHostEntry($shareserver)).HostName -split "\."
				
				if ($shareserver -ne $hostentry[0])
				{
					Write-Warning "Using CNAME records for the network share may present an issue if an SPN has not been created. Trying anyway. If it doesn't work, use a different (A record) hostname."
				}
			}
		}
		
		Write-Output "Resolving NetBIOS names"
		$sourcenetbios = Resolve-NetBiosName $sourceserver
		$destnetbios = Resolve-NetBiosName $destserver
		
		Write-Output "Performing SMO version check"
		Invoke-SmoCheck -SqlServer $sourceserver
		Invoke-SmoCheck -SqlServer $destserver
		
		Write-Output "Checking to ensure the source isn't the same as the destination"
		if ($source -eq $destination)
		{
			throw "Source and Destination Sql Servers instances are the same. Quitting."
		}
		
		if ($NetworkShare.Length -gt 0)
		{
			Write-Output "Checking to ensure network path is valid"
			if (!($NetworkShare.StartsWith("\\")))
			{
				throw "Network share must be a valid UNC path (\\server\share)."
			}
			
			try
			{
				if (Test-Path $NetworkShare -ErrorAction Stop)
				{
					Write-Verbose "$networkshare share can be accessed."
				}
			}
			catch
			{
				Write-Warning "$networkshare share cannot be accessed. Still trying anyway, in case the SQL Server service accounts have access."
			}
			
		}
		
		Write-Output "Checking to ensure server is not SQL Server 7 or below"
		if ($sourceserver.versionMajor -lt 8 -and $destserver.versionMajor -lt 8)
		{
			throw "This script can only be run on Sql Server 2000 and above. Quitting."
		}
		
		Write-Output "Checking to ensure detach/attach is not attempted on SQL Server 2000"
		if ($destserver.versionMajor -lt 9 -and $DetachAttach)
		{
			throw "Detach/Attach not supported when destination Sql Server is version 2000. Quitting."
		}
		
		Write-Output "Checking to ensure SQL Server 2000 migration isn't directly attempted to SQL Server 2012"
		if ($sourceserver.versionMajor -lt 9 -and $destserver.versionMajor -gt 10)
		{
			throw "Sql Server 2000 databases cannot be migrated to Sql Server versions 2012 and above. Quitting."
		}
		
		Write-Verbose "Warning if migration from 2005 to 2012 and above and attach/detach is used."
		if ($sourceserver.versionMajor -eq 9 -and $destserver.versionMajor -gt 9 -and !$BackupRestore -and !$Force -and $DetachAttach)
		{
			throw "Backup and restore is the safest method for migrating from Sql Server 2005 to other Sql Server versions.
		Please use the -BackupRestore switch or override this requirement by specifying -Force."
		}
		
		if ($sourceserver.collation -ne $destserver.collation)
		{
			Write-Output "Warning on different collation"
			Write-Warning "Collation on $Source, $($sourceserver.collation) differs from the $Destination, $($destserver.collation)."
		}
		
		Write-Output "Ensuring user databases exist (counting databases)"
		$dbtotal = $sourceserver.Databases.count
		
		if ($dbtotal -le 4)
		{
			throw "No user databases to migrate. Quitting."
		}
		
		Write-Output "Ensuring destination server version is equal to or greater than source"
		if ([version]$sourceserver.ResourceVersionString -gt [version]$destserver.ResourceVersionString)
		{
			throw "Source Sql Server version build must be <= destination Sql Server for database migration."
		}
		
		# SMO's filestreamlevel is sometimes null
		$sql = "select coalesce(SERVERPROPERTY('FilestreamConfiguredLevel'),0) as fs"
		$sourcefilestream = $sourceserver.ConnectionContext.ExecuteScalar($sql)
		$destfilestream = $destserver.ConnectionContext.ExecuteScalar($sql)
		if ($sourcefilestream -gt 0 -and $destfilestream -eq 0) { $fswarning = $true }
		
		Write-Output "Writing warning about filestream being enabled"
		if ($fswarning)
		{
			Write-Warning "FILESTREAM enabled on $source but not $destination. Databases that use FILESTREAM will be skipped."
		}
		
		if ($DetachAttach -eq $true)
		{
			Write-Output "Checking access to remote directories"
			$remotesourcepath = Join-AdminUNC $sourcenetbios (Get-SqlDefaultPaths $sourceserver data)
			
			If ((Test-Path $remotesourcepath) -ne $true -and $DetachAttach)
			{
				Write-Warning "Can't access remote Sql directories on $source which is required to perform detach/copy/attach."
				Write-Warning "You can manually try accessing $remotesourcepath to diagnose any issues."
				Write-Warning "Halting database migration."
				return
			}
			
			$remotedestpath = Join-AdminUNC $destnetbios (Get-SqlDefaultPaths $destserver data)
			If ((Test-Path $remotedestpath) -ne $true -and $DetachAttach)
			{
				Write-Warning "Can't access remote Sql directories on $destination which is required to perform detach/copy/attach."
				Write-Warning "You can manually try accessing $remotedestpath to diagnose any issues."
				Write-Warning "Halting database migration."
				return
			}
		}
		
		if (($Databases -or $Exclude -or $IncludeSupportDbs) -and (!$DetachAttach -and !$BackupRestore))
		{
			throw "You did not select a migration method. Please use -BackupRestore or -DetachAttach"
		}
		
		if ((!$Databases -and !$AllDatabases -and !$IncludeSupportDbs) -and ($DetachAttach -or $BackupRestore))
		{
			throw "You did not select any databases to migrate. Please use -AllDatabases or -Databases or -IncludeSupportDbs"
		}
		
		
		
		Write-Output "Building database list"
		$databaselist = New-Object System.Collections.ArrayList
		$SupportDBs = "ReportServer", "ReportServerTempDB", "distribution"
		foreach ($database in $sourceserver.Databases)
		{
			$dbname = $database.name
			$dbowner = $database.Owner
			
			if ($database.id -le 4) { continue }
			if ($Databases -and $Databases -notcontains $dbname) { continue }
			if ($IncludeSupportDBs -eq $false -and $SupportDBs -contains $dbname) { continue }
			if ($IncludeSupportDBs -eq $true -and $SupportDBs -notcontains $dbname)
			{
				if ($AllDatabases -eq $false -and $Databases.length -eq 0) { continue }
			}
			$null = $databaselist.Add($database)
		}
		
		Write-Verbose "Performing count"
		$dbcount = $databaselist.Count
		
		Write-Output "Building file structure inventory for $dbcount databases"
		
		if ($sourceserver.versionMajor -eq 8)
		{
			$sql = "select DB_NAME (dbid) as dbname, name, filename, CASE WHEN groupid = 0 THEN 'LOG' ELSE 'ROWS' END as filetype from sysaltfiles"
		}
		else
		{
			$sql = "SELECT db.name AS dbname, type_desc AS FileType, mf.name, Physical_Name AS filename FROM sys.master_files mf INNER JOIN  sys.databases db ON db.database_id = mf.database_id"
		}
		
		$dbfiletable = $sourceserver.Databases['master'].ExecuteWithResults($sql)
		
		if ($destserver.versionMajor -eq 8)
		{
			$sql = "select DB_NAME (dbid) as dbname, name, filename, CASE WHEN groupid = 0 THEN 'LOG' ELSE 'ROWS' END as filetype from sysaltfiles"
		}
		else
		{
			$sql = "SELECT db.name AS dbname, type_desc AS FileType, mf.name, Physical_Name AS filename FROM sys.master_files mf INNER JOIN  sys.databases db ON db.database_id = mf.database_id"
		}
		
		$remotedbfiletable = $destserver.Databases['master'].ExecuteWithResults($sql)
		
		$filestructure = Get-SqlFileStructure -sourceserver $sourceserver -destserver $destserver -databaselist $databaselist -ReuseSourceFolderStructure $ReuseSourceFolderStructure
		
		$elapsed = [System.Diagnostics.Stopwatch]::StartNew()
		$started = Get-Date
		$script:timenow = (Get-Date -uformat "%m%d%Y%H%M%S")
		
		$alldbelapsed = [System.Diagnostics.Stopwatch]::StartNew()
		
		if ($AllDatabases -or $Exclude.length -gt 0 -or $IncludeSupportDbs -or $Databases.length -gt 0)
		{
			foreach ($database in $databaselist)
			{
				$dbelapsed = [System.Diagnostics.Stopwatch]::StartNew()
				$dbname = $database.name
				$dbowner = $database.Owner
				
				Write-Output "`n######### Database: $dbname #########"
				$dbstart = Get-Date
				
				if ($exclude -contains $dbname)
				{
					Write-Output "$dbname excluded. Skipping."
					continue
				}
				
				Write-Verbose "Checking for accessibility"
				if ($database.IsAccessible -eq $false)
				{
					Write-Warning "Skipping $dbname. Database is inaccessible."
					continue
				}
				
				if ($fswarning)
				{
					$fsrows = $dbfiletable.Tables[0].Select("dbname = '$dbname' and FileType = 'FileStream'")
					
					if ($fsrows.count -gt 0)
					{
						Write-Warning "Skipping $dbname (contains FILESTREAM)"
						continue
					}
				}
				
				if ($ReuseSourceFolderStructure)
				{
					$fgrows = $dbfiletable.Tables[0].Select("dbname = '$dbname' and FileType = 'ROWS'")[0]
					$remotepath = Split-Path $fgrows
					$remotepath = Join-AdminUNC $destnetbios $remotepath
					
					if (!(Test-Path $remotepath)) { throw "Cannot resolve $remotepath. `n`nYou have specified ReuseSourceFolderStructure and exact folder structure does not exist. Halting script." }
				}
				
				Write-Verbose "Checking Availability Group status"
				if ($database.AvailabilityGroupName.Length -gt 0 -and !$force -and $DetachAttach)
				{
					$agname = $database.AvailabilityGroupName
					Write-Warning "Database is part of an Availability Group ($agname). Use -Force to drop from $agname and migrate. Alternatively, you can use the safer backup/restore method."
					continue
				}
				
				$dbstatus = $database.status.toString()
				
				if ($dbstatus.StartsWith("Normal") -eq $false)
				{
					Write-Warning "$dbname is not in a Normal state. Skipping."
					continue
				}
				
				if ($database.ReplicationOptions -ne "None" -and $DetachAttach -eq $true)
				{
					Write-Warning "$dbname is part of replication. Skipping."
					continue
				}
				
				if ($database.IsMirroringEnabled -and !$force -and $DetachAttach)
				{
					Write-Warning "Database is being mirrored. Use -Force to break mirror and migrate. Alternatively, you can use the safer backup/restore method."
					continue
				}
				
				if (($destserver.Databases[$dbname] -ne $null) -and !$force -and !$WithReplace)
				{
					Write-Warning "Database exists at destination. Use -Force to drop and migrate. Aborting routine for this database."
					continue
				}
				elseif ($destserver.Databases[$dbname] -ne $null -and $force)
				{
					If ($Pscmdlet.ShouldProcess($destination, "DROP DATABASE $dbname"))
					{
						Write-Output "$dbname already exists. -Force was specified. Dropping $dbname on $destination."
						$dropresult = Remove-SqlDatabase $destserver $dbname
						
						if ($dropresult -eq $false)
						{
							Write-Warning "Database could not be dropped. Aborting routine for this database"
							continue
						}
					}
				}
				
				If ($Pscmdlet.ShouldProcess("console", "Showing start time"))
				{
					Write-Output "Started: $dbstart"
				}
				
				if ($sourceserver.versionMajor -ge 9)
				{
					$sourcedbownerchaining = $sourceserver.databases[$dbname].DatabaseOwnershipChaining
					$sourcedbtrustworthy = $sourceserver.databases[$dbname].Trustworthy
					$sourcedbbrokerenabled = $sourceserver.databases[$dbname].BrokerEnabled
					
				}
				
				$sourcedbreadonly = $sourceserver.Databases[$dbname].ReadOnly
				
				if ($SetSourceReadOnly)
				{
					If ($Pscmdlet.ShouldProcess($source, "Set $dbname to read-only"))
					{
						Write-Output "Setting database to read-only"
						$result = Update-SqldbReadOnly $sourceserver $dbname $true
						
						if ($result -eq $false)
						{
							Write-Warning "Couldn't set database to read-only. Aborting routine for this database"
							continue
						}
					}
				}
				
				if ($BackupRestore)
				{
					If ($Pscmdlet.ShouldProcess($destination, "Backup $dbname from $source and restoring."))
					{
						$filename = "$dbname-$timenow.bak"
						$backupfile = Join-Path $networkshare $filename
						
						$backupresult = Backup-SqlDatabase $sourceserver $dbname $backupfile $numberfiles
						
						if ($backupresult -eq $false)
						{
							$serviceaccount = $sourceserver.ServiceAccount
							Write-Warning "Backup Failed. Does Sql Server account $serviceaccount have access to $NetworkShare? Aborting routine for this database"
							continue
						}
						
						$restoreresult = Restore-SqlDatabase $destserver $dbname $backupfile $filestructure $numberfiles
						
						if ($restoreresult -eq $true)
						{
							Write-Output "Successfully restored $dbname to $destination"
						}
						else
						{
							if ($ReuseSourceFolderStructure)
							{
								Write-Warning "Failed to restore $dbname to $destination. You specified -ReuseSourceFolderStructure. Does the exact same destination directory structure exist?"
								Write-Warning "Aborting routine for this database"
								continue
							}
							else
							{
								Write-Warning "Failed to restore $dbname to $destination. Aborting routine for this database."
								continue
							}
						}
					}
					
					$dbfinish = Get-Date
					
					if ($norecovery -eq $false)
					{
						Write-Output "Updating database owner"
						$result = Update-Sqldbowner $sourceserver $destserver -dbname $dbname
					}
					
				}
				
				if ($DetachAttach)
				{
					$sourcefilestructure = New-Object System.Collections.Specialized.StringCollection
					foreach ($file in $filestructure.databases[$dbname].source.values)
					{
						$null = $sourcefilestructure.add($file.physical)
					}
					
					$dbowner = $sourceserver.databases[$dbname].owner
					
					if ($dbowner -eq $null)
					{
						$dbowner = Get-SaLoginName -SqlServer $destserver
					}
					
					If ($Pscmdlet.ShouldProcess($destination, "Detach $dbname from $source and attach, then update dbowner"))
					{
						$migrationresult = Start-SqlDetachAttach $sourceserver $destserver $filestructure $dbname
						
						$dbfinish = Get-Date
						
						if ($reattach -eq $true)
						{
							$null = ($sourceserver.databases).Refresh()
							$result = Mount-SqlDatabase $sourceserver $dbname $sourcefilestructure $dbowner
							
							if ($result -eq $true)
							{
								$sourceserver.databases[$dbname].DatabaseOwnershipChaining = $sourcedbownerchaining
								$sourceserver.databases[$dbname].Trustworthy = $sourcedbtrustworthy
								$sourceserver.databases[$dbname].BrokerEnabled = $sourcedbbrokerenabled
								$sourceserver.databases[$dbname].alter()
								
								if ($SetSourceReadOnly)
								{
									$null = Update-SqldbReadOnly $sourceserver $dbname $true
								}
								else
								{
									$null = Update-SqldbReadOnly $sourceserver $dbname $sourcedbreadonly
								}
								
								Write-Output "Successfully reattached $dbname to $source"
							}
							else
							{
								Write-Warning "Could not reattach $dbname to $source."
							}
						}
						
						
						if ($migrationresult -eq $true)
						{
							Write-Output "Successfully attached $dbname to $destination"
						}
						else
						{
							Write-Warning "Failed to attach $dbname to $destination. Aborting routine for this database."
							continue
						}
					}
				}
				
				# restore poentially lost settings
				
				if ($destserver.versionMajor -ge 9 -and $norecovery -eq $false)
				{
					if ($sourcedbownerchaining -ne $destserver.databases[$dbname].DatabaseOwnershipChaining)
					{
						If ($Pscmdlet.ShouldProcess($destination, "Updating DatabaseOwnershipChaining on $dbname"))
						{
							try
							{
								$destserver.databases[$dbname].DatabaseOwnershipChaining = $sourcedbownerchaining
								$destserver.databases[$dbname].Alter()
								Write-Output "Successfully updated DatabaseOwnershipChaining for $sourcedbownerchaining on $dbname on $destination"
							}
							catch
							{
								Write-Warning "Failed to update DatabaseOwnershipChaining for $sourcedbownerchaining on $dbname on $destination"
								Write-Exception $_
							}
						}
					}
					
					if ($sourcedbtrustworthy -ne $destserver.databases[$dbname].Trustworthy)
					{
						If ($Pscmdlet.ShouldProcess($destination, "Updating Trustworthy on $dbname"))
						{
							try
							{
								$destserver.databases[$dbname].Trustworthy = $sourcedbtrustworthy
								$destserver.databases[$dbname].alter()
								Write-Output "Successfully updated Trustworthy to $sourcedbtrustworthy for $dbname on $destination"
							}
							catch
							{
								Write-Warning "Failed to update Trustworthy to $sourcedbtrustworthy for $dbname on $destination"
								Write-Exception $_
							}
						}
					}
					
					if ($sourcedbbrokerenabled -ne $destserver.databases[$dbname].BrokerEnabled)
					{
						If ($Pscmdlet.ShouldProcess($destination, "Updating BrokerEnabled on $dbname"))
						{
							try
							{
								$destserver.databases[$dbname].BrokerEnabled = $sourcedbbrokerenabled
								$destserver.databases[$dbname].Alter()
								Write-Output "Successfully updated BrokerEnabled to $sourcedbbrokerenabled for $dbname on $destination"
							}
							catch
							{
								Write-Warning "Failed to update BrokerEnabled to $sourcedbbrokerenabled for $dbname on $destination"
								Write-Exception $_
							}
						}
					}
				}
				
				if ($sourcedbreadonly -ne $destserver.databases[$dbname].ReadOnly -and $norecovery -eq $false)
				{
					If ($Pscmdlet.ShouldProcess($destination, "Updating ReadOnly status on $dbname"))
					{
						$update = Update-SqldbReadOnly $destserver $dbname $sourcedbreadonly
						if ($update -eq $true)
						{
							"Successfully updated readonly status on $dbname"
						}
						else
						{
							Write-Warning "Failed to update ReadOnly status on $dbname"
							Write-Exception $_
						}
					}
				}
				
				
				If ($Pscmdlet.ShouldProcess("console", "Showing elapsed time"))
				{
					$dbtotaltime = $dbfinish - $dbstart
					$dbtotaltime = ($dbtotaltime.toString().Split(".")[0])
					
					Write-Output "Finished: $dbfinish"
					Write-Output "Elapsed time: $dbtotaltime"
				}
			} # end db by db processing
		}
	}
	
	END
	{
		If ($Pscmdlet.ShouldProcess("console", "Showing migration time elapsed"))
		{
			$totaltime = ($elapsed.Elapsed.toString().Split(".")[0])
			
			Write-Output "`nDatabase migration finished"
			Write-Output "Migration started: $started"
			Write-Output "Migration completed: $(Get-Date)"
			Write-Output "Total Elapsed time: $totaltime"
			
			if ($networkshare.length -gt 0 -and $NoBackupCleanup)
			{
				Write-Warning "Backups still exist at $networkshare."
			}
		}
		
		$sourceserver.ConnectionContext.Disconnect()
		$destserver.ConnectionContext.Disconnect()
	}
}
